# Описание

Выполнена система в компонентном (модульном) стиле, максимально связанные классы находятся в одном компоненте, 
компоненты связаны общей областью (в нашем случае сценой, либо назначением в системе в случае с данными). 

Модуль Stable немного концептуально неверен, так как с развитием проекта он наверняка оказался бы излишне ответственнен, 
однако излишнее внимание к подобным деталям в ситуации проекта из тестового задания выглядело бы как оверинжиниринг. 

В компонентах системы находятся подкомпоненты характерные для используемой области, либо имеющие особую связь, 
имеющие общую задачу (такой как подмодуль UI в компонентах Menu и Ride)

## Данные

Все находящееся в папке [Data](Data) относится к реализации хранения данных, выполнено хранение максимально примитивно, чтобы не заострять на этом внимание.

### [Data/IInteger](Data/IInteger.cs) 

Определяет простой интерфейс предназначенный для ввода/вывода числовых данных, 
в то же время имя подразумевает контракт, что это ***одно*** число.

### [Data/IntegerPlayerPrefs](Data/IntegerPlayerPrefs.cs) 

Реализует интерфейс **IInteger**, инкапсулируя способ хранения данных, в этом случае: константу-ключ для
доступа к данным находящимся в **PlayerPrefs** и обращения к специфичному для платформы PlayerPrefs (Unity при билде WebGL хранит такие данные как cookie).

## Меню

В модуле **Menu** (и соответствующей папке) содержатся компоненты, реализующие логику представления данных из последней игры в главном меню

### [Menu/UI/PlayButtonListener](Menu/UI/PlayButtonListener.cs)

Предназначен для перенаправления в сцену игры. Перенаправление не происходит напрямую (через UnityEvent в Button), 
чтобы в процессе обслуживания не требовалось лезть в UI, который при своей подверженности 
изменчивости имеет склонность усложняться. Так, модуль касающийся перенаправлений может оказаться в предсказуемом и желаемом для разработчика месте в корне иерархии.

### [Menu/UI/ScoreWindow](Menu/UI/ScoreWindow.cs)

Показывает данные о последнем счете в игре на окне. Логика отображения здесь выражается в изменении компонента **TMP_Text**. Этот класс имеет небольшой
контракт через метод Construct, ему требуется источник данных для работы, который он получает от адаптера.

> Эта логика содержится в базовом классе [Window](Stable/Window/Window.cs), который имеет публичный интерфейс открытия/закрытия окна, при этом при открытии окна
он заполняет в переданный в инспекторе компонент **TMP_Text** некоторый текст, определяемый наследником. 

Наследник ScoreWindow устанавливает в окне текст из конкретного
источника данных, в любом случае при усложнении логики отображения в наследнике или изменении источника данных можно было бы изменить принимамый тип в Construct на 
интерфейс для защиты от изменения источника данных, но в этой ситуации разработки это скорее неактуально, хоть ничего и не мешает это сделать.

### [Menu/UI/ScoreWindowAdapter](Menu/UI/ScoreWindowAdapter.cs)

По сути чем-то похож на паттерн Humble Object, кроме этого больше похож на контроллер в стиле MVC из ASP.NET. Предназначен для построения соответствующего вида 
(передачи ему данных) и синхронизации работы [WindowController](Stable/Window/WindowController.cs) с открытием/закрытием окна.

## Гонка

Компоненты связанные с модулем **Ride** содержатся в одноименной папке. В ней находятся компоненты с общей областью - сценой Game.

### Игровой уровень ([GameLevel](Ride/GameLevel))

Этот компонент содержит классы связанные с обнаружением приближения игрока к финишу.

### Игрок ([ссылка](Ride/Player))

Здесь [Player](Ride/Player/Player.cs) больше похож на модель игрока, где Unity представляет собой вид, а 
[PlayerController](Ride/Player/PlayerController.cs) контроллер. Класс Player создан с допущением, что мы никогда не изменим Unity на другой движок, для 
этого класса. PlayerController довольно типичен для управления пользователя в большинстве игр на Unity. Ну и класс [ThirdPersonCamera](Ride/Player/ThirdPersonCamera.cs)
предоставляет слежение камеры за игроком. Ракурс камеры в итоговой игре было бы здорово изменить на ракурс из игры Ballance, здесь камера не вращается примерно из этого же
соображения.

### UI ([ссылка](Ride/UI))

Компонент UI содержит схожую логику что и в компоненте Menu, но адаптер окна проигрыша достаточно "тупой" и просто показывает окно по команде и переходит в меню по нажатию Escape.

Адаптер окна делает тоже что и адаптер окна последнего результата из Menu, но кроме этого еще сохраняет данные.

Здесь же встречается Window как базовый класс, логика отображения окон не меняется, этот класс идеально подходит.

## Stable ([ссылка](Stable))

Сборник самых стабильных классов системы (по определению дяди Боба, стабильными называются классы у которых отношение входящих зависимостей ко всем зависимостям равна единице). 
Этот модуль по идее подчиняется сугубо OCP, изменения здесь очень нежелательны.

### [HumanizedTime](Stable/HumanizedTime.cs)

Преобразует время в секундах (или TimeSpan с секундами) в удобочитаемое время формата ММ:CC. Используется окнами отображения результата.

### [Scene](Stable/Scene.cs) и [SceneTransitions](Stable/SceneTransitions.cs)

Scene по сути перечисление имен сцен, а SceneTransitions инкапсулирует переход между сценами

### [Window](Stable/Window)

Небольшой компонент реализующий отображение окон в этой системе. Управление окном реализовано в [контроллере окон](Stable/Window/WindowController.cs), ранее упомянутый
базовый класс для простого управления окнами в абстрактном классе [Window](Stable/Window/Window.cs).
